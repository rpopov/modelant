Conventions
===========

Elicited conventions and lessons learned

GAV Coordinates
---------------

**\[C1\]** All components of ModelAnt have the same group name **net.mdatools**.

**\[C2\]** Each component of ModelAnt has its artifact ID as a path starting form **modelant**.

**\[C3\]** The versioning is semantic **&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;** starting from 3 major version, as Modelant for Maven is a completely new version of ModelAnt 2.x

Directories
-----------

**\[C4\]** Even though ModelAnt is migrated Maven, I decide not to follow the "Maven standard" directories structure in terms:

    * "main" is no more alternative/opposition of "test" directory name
    * all languages are treated equally
    * **src\&lt;language&gt;** directory contains the source code in the corresponding language:
        * java
        * model
        * template        
        * ...
    * **src\resources** directory contains the resources to be included directly in the result artifact
    * **src\site** directory contains 
        * **site.xml** file of the documentation
        * **markdown** directory contains the manually-written files in [Markdown format](https://daringfireball.net/projects/markdown/syntax) to be included in the generated documentation, like:
            * index.md
            * faq.md
    * **test\&lt;language&gt;** directory contains the source code in the corresponding language:
        * java
        * maven (see \[A5\]) containing
            * **settings.xml** for the test build to initiate
            * **&lt;test/issue id&gt;** directory - contains the test project contents, including the **pom.xml** of the project
        * ...
    * **test\resources** directory contains the test resources to be included directly in the test artifact
    * **target\site** directory contains the generated site/javadoc **for the component** (as of maven convention), because:
        * the site is not the source code, but it is derived from it, like the compiled code
        * the component's site is zipped and published with the component
        * the component's source code is zipped and published with the component in order to support development with and debug of modelant is a third party component
    * any components are published in the Maven repositories, thus no **lib** directory is needed. In case components / libraries cannot be found in any public repository, extract them as modules and define their POM to export them in a public repositories.

# Maven Plugins / Mojo

**\[C5\]**  Name the Mojo class **&lt;Operation name&gt;Mojo extends AbstractMojo**. Always use the javadoc style of Mojo annotation as follows:
    /**
     * ...
     * @author Rusi Popov
     */
    @Mojo(name="&lt;goal name of this mojo in kebab case&gt;",
          defaultPhase=LifecyclePhase.COMPILE
    )
    @Execute(phase=LifecyclePhase.COMPILE)
    public class &lt;Purpose of this Mojo&gt;Mojo extends CompilationContext ...

  **\[C5.1\]**  Always use the javadoc style of Mojo annotation for parameters:
    /**
     * The file to produce
     */
    @Parameter(required=true)
    private File targetFile;

    /**
     * Selection of all ModelAnt Templates below sourceDirectory
     */
    @Parameter
    private FileSet fileSet;

    /**
     * Where to generate the API sources
     */
    @Parameter(property="project.build.sourceDirectory", required=true)
    private File sourceDirectory;

    /**
     * Where the work files are located
     */
    @Parameter(property="project.build.directory", required=true)
    private File workDirectory;

**\[C5.2\]**  Mojo logging - use the Maven-provided logging mechanism:
    getLog().warn("warning...");
    ...
    if (getLog().isDebugEnabled()) {
      getLog().debug("debug...");
    }

    
**\[C6\]** When including the mojo in artifacts generated by ModelAnt, refer both the goal name and execution phase (no matter the phase has a default) to make the binding explicit. Then anyone else would not need to read the Mojo to identify when it is activated:
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;phase&gt;generate-sources&lt;/phase&gt;
        &lt;goals&gt;
          &lt;goal&gt;generate-model-api&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
          &lt;metamodelFile&gt;${metamodelUrl}&lt;/metamodelFile&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;            

**\[C7\]** When including the Mojo in **manually written** artifacts it is enough to provide just the goal name (the phase is by default, no need of &lt;id&gt;,..):
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;goals&gt;
          &lt;goal&gt;compile-templates&lt;/goal&gt;
        &lt;/goals&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
Maven will use the default phase from the class' annotation to bind the plugin in \[http://maven.apache.org/guides/mini/guide-configuring-plugins.html#Mapping_Complex_Objects Mapping Complex Objects in Maven\]

**\[C8\]** Testing the plugin uses the https://maven.apache.org/plugins/maven-invoker-plugin plugin defined in the **maven-plugin** profile, where:

    * **test/maven** directory contains
        * settings.xml
        * **&lt;issue id&gt;** directory contains
          * pom.xml where 
          * the current artifact version is referred as **@project.version@**
          * the current version of the parent pom is referred as **@project.parent.version@**

**\[C9\]** When publishing/distributing ModelAnt, publish the source code and javadoc too. This will support the further development based on those components and IDE integration:

    * https://maven.apache.org/plugin-developers/cookbook/attach-source-javadoc-artifacts.html
    * Verify the generated documentation, according to https://maven.apache.org/plugin-developers/plugin-documenting.html&lt;br/&gt;The maven-docck-plugin can be run:
      mvn docck:check

# Best Practices

**\[C10\]** Integrate the unit tests in the development (implementation) project, whereas the API project does not provide any tests. This way the API can be compiled first and independently of the implementation(s), avoiding cyclic dependencies and monolith development.

**\[C11\]** Extract an **integration test** project, consisting only of the **API test code**, with all needed dependencies and (default) implementations. There is no need of other than test/java directory.

# Naming Convention

**\[C20\]** For each language supported (i.e. metamodel), there are:

    * Maven project with artifact ID: **modelant.&lt;language name&gt;.metamodel**
    * The Maven project consists of the package: **net.mdatools.modelant.&lt;language name&gt;.metamodel**
    * The package contains:
        * Model factory, named: **&lt;language&gt;ModelFactory**, extending BaseModelFactory
        * Operation to print any elements of models in that language (metamodel), named: **Print&lt;language&gt;ModelElement**
        * Operation to compare models in that language, named: **Compare&lt;language&gt;Models**

**\[C21\]**  Functions and Operations naming convention: **&lt;Verb&gt;\[&lt;adjective&gt;&lt;direct object&gt;\]**

**\[C22\]**  Selectors naming convention: **Select\[&lt;adjective&gt;\]&lt;direct object&gt;** as a special case of Function

# Maven Conventions

**\[C30\]** The root Maven POM.xml defines the profiles to compile / build the artifacts in the whole project set. The activation of the profiles though, due to some Maven specifics, cannot be based on contents of the POM.xml itself, then the activation of the Maven profile will be based on the presence of file named like:
    profile.&lt;profile name&gt;

Examples:
    profile.maven-plugin - activates the maven-plugin profile for the artifact to build

**\[C31\]** As of \[A5\], the maven plugin profile includes the mechanism **maven-invoker-plugin** to test  the maven plugins. See: https://maven.apache.org/plugin-developers/plugin-testing.html

**\[C32\]** As of https://maven.apache.org/pom.html#Dependencies when referring the JAVA platform tools as **dependencies** (not published as Maven artifacts) use:

    * **system** scope
    * **systemPath** defined through an **explicitly set property** or Java **system property** (like ${java.home}), but **not** as an environmental one, as env.XYZ may not  exist by the moment of running.
    Example:
    &lt;dependency&gt;
      &lt;groupId&gt;java.tools&lt;/groupId&gt;
      &lt;artifactId&gt;dt&lt;/artifactId&gt;
      &lt;version&gt;1.8&lt;/version&gt;
      &lt;scope&gt;**system**&lt;/scope&gt;
      &lt;systemPath&gt;**${java.home}**/../lib/tools.jar&lt;/systemPath&gt;
    &lt;/dependency&gt;
**Note:** This definition causes problems under Eclipse with default setup with default Java setup under Windows, because of the spaces in the path. Therefore apply the \[\[Modelant - migration to maven#Eclipse_Setup_Procedure_for_Windows|Eclipse Setup Procedure for Windows\]\]
